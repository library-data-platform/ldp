#include <stdexcept>

#include "dbtype.h"

dbtype::dbtype(etymon::pgconn* conn)
{
    string dbms_name;
    //conn->get_dbms_name(&dbms_name);
    //set_type(dbms_name);
    set_type("PostgreSQL");
}

void dbtype::set_type(const string& dbms)
{
    if (dbms == "PostgreSQL") {
        dbt = dbsys::postgresql;
    } else {
        if (dbms == "Redshift") {
            dbt = dbsys::redshift;
        } else {
            string err = "Unknown database system: \"";
            err += dbms;
            err += "\"";
            throw runtime_error(err);
        }
    }
}

const char* dbtype::json_type() const
{
    switch (dbt) {
    case dbsys::postgresql:
	return "JSONB";
    case dbsys::redshift:
	return "VARCHAR(65535)";
    default:
	return "(unknown)";
    }
}

const char* dbtype::current_timestamp() const
{
    switch (dbt) {
        case dbsys::postgresql:
            return "CURRENT_TIMESTAMP";
        case dbsys::redshift:
            return "SYSDATE";
        default:
            return "(unknown)";
    }
}

void dbtype::rename_sequence(const string& sequence_name,
        const string& new_sequence_name, string* sql) const
{
    switch (dbt) {
        case dbsys::postgresql:
            *sql =
                "ALTER SEQUENCE IF EXISTS\n"
                "    " + sequence_name + "\n"
                "    RENAME TO " + new_sequence_name + ";";
            return;
        case dbsys::redshift:
            *sql = "";
            return;
        default:
            *sql = "(unknown)";
            return;
    }
}

void dbtype::create_sequence(const string& sequence_name, int64_t start,
        string* sql) const
{
    switch (dbt) {
        case dbsys::postgresql:
            *sql =
                "CREATE SEQUENCE " + sequence_name + "\n"
                "    START " + to_string(start) + ";";
            return;
        case dbsys::redshift:
            *sql = "";
            return;
        default:
            *sql = "(unknown)";
            return;
    }
}

void dbtype::auto_increment_type(int64_t start, bool named_sequence,
        const string& sequence_name, string* sql) const
{
    switch (dbt) {
        case dbsys::postgresql:
            if (named_sequence)
                *sql =
                    "BIGINT NOT NULL\n"
                    "        DEFAULT\n"
                    "        nextval('" + sequence_name +
                    "')";
            else
                *sql = "BIGSERIAL";
            return;
        case dbsys::redshift:
            *sql = "BIGINT GENERATED BY DEFAULT AS IDENTITY(" +
                to_string(start) + ", 1)";
            return;
        default:
            *sql = "(unknown)";
            return;
    }
}

void dbtype::alter_sequence_owned_by(const string& sequence_name,
        const string& table_column_name, string* sql) const
{
    switch (dbt) {
        case dbsys::postgresql:
            *sql =
                "ALTER SEQUENCE " + sequence_name + "\n"
                "    OWNED BY " + table_column_name + ";";
            return;
        case dbsys::redshift:
            *sql = "";
            return;
        default:
            *sql = "(unknown)";
            return;
    }
}

const char* dbtype::type_string() const
{
    switch (dbt) {
        case dbsys::postgresql:
            return "PostgreSQL";
        case dbsys::redshift:
            return "Redshift";
        default:
            return "(unknown)";
    }
}

dbsys dbtype::type() const
{
    return dbt;
}

void dbtype::encode_copy(const char* str, string* newstr) const
{
    newstr->clear();
    const char *p = str;
    char c;
    while ( (c=*p) != '\0') {
        switch (c) {
            case '\\':
                *newstr += "\\\\";
                break;
            case '\b':
                *newstr += "\\b";
                break;
            case '\f':
                *newstr += "\\f";
                break;
            case '\n':
                *newstr += "\\n";
                break;
            case '\r':
                *newstr += "\\r";
                break;
            case '\t':
                *newstr += "\\t";
                break;
            case '\v':
                *newstr += "\\v";
                break;
            default:
                *newstr += c;
        }
        p++;
    }
}

static void encode_str(const char* str, string* newstr, bool e)
{
    if (e)
        *newstr = "E'";
    else
        *newstr = '\'';
    const char *p = str;
    char c;
    while ( (c=*p) != '\0') {
        switch (c) {
            case '\\':
                *newstr += "\\\\";
                break;
            case '\'':
                *newstr += "''";
                break;
            case '\b':
                *newstr += "\\b";
                break;
            case '\f':
                *newstr += "\\f";
                break;
            case '\n':
                *newstr += "\\n";
                break;
            case '\r':
                *newstr += "\\r";
                break;
            case '\t':
                *newstr += "\\t";
                break;
            default:
                *newstr += c;
        }
        p++;
    }
    *newstr += '\'';
}

void dbtype::encode_string_const(const char* str, string* newstr) const
{
    switch (dbt) {
        case dbsys::postgresql:
            encode_str(str, newstr, true);
            break;
        case dbsys::redshift:
            encode_str(str, newstr, false);
            break;
        case dbsys::unknown:
            *newstr = "(unknown)";
            break;
    }
}

void dbtype::redshift_keys(const char* distkey, const char* sortkey,
            string* sql) const
{
    switch (dbt) {
        case dbsys::postgresql:
            (*sql) = "";
            break;
        case dbsys::redshift:
            (*sql) = string(" DISTKEY(") + distkey +
                string(") COMPOUND SORTKEY(") + sortkey + string(")");
            break;
        case dbsys::unknown:
            (*sql) = "(unknown)";
            break;
    }
}


